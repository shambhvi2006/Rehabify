<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rehabify â€” Single File Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- MediaPipe (order matters; no async/defer) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

  <style>
    :root { --bg:#0b1220; --panel:#0f172a; --text:#e5e7eb; --accent:#22c55e; --muted:#94a3b8; }
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:#0b1220;color:var(--text)}
    header{position:sticky;top:0;display:flex;justify-content:space-between;align-items:center;background:#0d1324;padding:14px 18px}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}
    .stage{position:relative;display:grid;grid-template-columns:300px 1fr;gap:18px}
    .panel{background:var(--panel);border-radius:16px;padding:14px}
    .metrics{line-height:1.8} .big{font-weight:700}
    progress{width:100%;height:12px;border-radius:999px;overflow:hidden}
    progress::-webkit-progress-bar{background:#1f2937} progress::-webkit-progress-value{background:#7c3aed}
    .canvas-wrap{position:relative}
    #overlay{width:min(90vw,750px);height:auto;background:#000;border-radius:16px;display:block}
    #video{display:none}
    #mascot{position:absolute;top:12px;right:14px;font-size:56px;pointer-events:none;transform-origin:center}
    @keyframes bop{0%{transform:translateY(0) rotate(0)}50%{transform:translateY(-10px) rotate(-6deg)}100%{transform:translateY(0) rotate(0)}}
    #mascot.celebrate{animation:bop .4s ease}
    .pill{border:0;padding:10px 14px;border-radius:12px;background:var(--accent);color:#081018;cursor:pointer;font-weight:600}
    .status{position:absolute;left:12px;top:12px;background:rgba(0,0,0,.55);padding:8px 10px;border-radius:10px;font:12px/1.5 ui-monospace,monospace}
  </style>
</head>
<body>
  <header>
    <h1>Rehabify</h1>
    <button id="startBtn" class="pill">Start Exercise</button>
  </header>

  <div class="wrap">
    <div class="stage">
      <!-- LEFT: HUD -->
      <div class="panel">
        <div class="metrics">
          <div>Score: <span class="big" id="score">0</span></div>
          <div id="exerciseInfo"></div>
          <div>Stars: <span class="big" id="stars">0</span></div>
          <div>Streak: <span class="big" id="streak">0</span></div>
          <div>Energy:</div>
          <progress id="energy" value="100" max="100"></progress>
        </div>
      </div>

      <!-- RIGHT: CAMERA + CANVAS -->
      <div class="canvas-wrap">
        <video id="video" autoplay muted playsinline></video>
        <div id="mascot">ðŸ•º</div>
        <canvas id="overlay"></canvas>
        <div class="status" id="status">idleâ€¦</div>
      </div>
    </div>
  </div>

  <script src="exercises.js"></script>
  <script>
    // ---------- DOM
    const video   = document.getElementById('video');
    const canvas  = document.getElementById('overlay');
    const ctx     = canvas.getContext('2d');
    const startBtn= document.getElementById('startBtn');
    const scoreEl = document.getElementById('score');
    const starsEl = document.getElementById('stars');
    const streakEl= document.getElementById('streak');
    const energyEl= document.getElementById('energy');
    const mascot  = document.getElementById('mascot');
    const statusEl= document.getElementById('status');
    const exerciseInfoEl = document.getElementById('exerciseInfo');
    function status(msg){ statusEl.textContent = msg; console.log(msg); }

    // ---------- GAME/POSE STATE
    let score=0, streak=0, energy=100, running=false;
    let starCount=0;
    let lastRepAt=0, framesCorrect=0;
    let latestLm = null;

    // Track current exercise and reps
    let currentExerciseIndex = 0;
    let repCount = 0;
    let currentExercise = exercises[currentExerciseIndex];

    // Tunables
    const REP_COOLDOWN_MS=600, NEED_CONSEC_FRAMES=3, VIS_THRESH=0.25;

    // ---------- AUDIO (ding)
    let audioCtx=null;
    function initAudio(){ 
        if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); 
    }// Creates a single global AudioContext the first time you call it.

    function playDing(){
      if (!audioCtx) return;
      const o = audioCtx.createOscillator();//Creates a tone generator
      const g = audioCtx.createGain();//creates a volume node
      o.type='sine'; //pure tone
      o.frequency.value=880;//pitch
      o.connect(g); 
      g.connect(audioCtx.destination);
      const t = audioCtx.currentTime;//precise audio clock
      g.gain.setValueAtTime(0, t);//starts silent
      g.gain.linearRampToValueAtTime(0.6, t+0.01);//quick fade in 10 ms
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.25);//fadeout
      o.start(t); // start
      o.stop(t+0.26);//stop
    }

    // ---------- CANVAS
    function setCanvasSize(){ 
      canvas.width=video.videoWidth; 
      canvas.height=video.videoHeight; 
      TARGET_SPAWN_Y = -60;                     
      MISS_Y = canvas.height * MISS_Y_FRAC;     
      if (currentExercise.criteria === 'shoulderAbduction') {
        setupRainbowStars();
      }
    }
    function drawCameraFrame(){
      if (video.readyState >= 2) {
        //video.readyState is a number:
        //0: HAVE_NOTHING
        //1: HAVE_METADATA
        //2: HAVE_CURRENT_DATA
        //3: HAVE_FUTURE_DATA
        //4: HAVE_ENOUGH_DATA
        ctx.save();
        ctx.scale(-1,1);
        ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
        ctx.restore();
      }
    }

    // ---------- LANDMARK UTILS
    function toPix(p){ 
        return { 
            x:(1-p.x)*canvas.width, 
            y:p.y*canvas.height, 
            c:(p.visibility ?? 1) 
        }; 
    }
    const visOK = p => !p || p.visibility===undefined || p.visibility>=VIS_THRESH;

    function angle(a,b,c){
      const abx=a.x-b.x, aby=a.y-b.y, cbx=c.x-b.x, cby=c.y-b.y;
      const dot=abx*cbx+aby*cby, mag=Math.hypot(abx,aby)*Math.hypot(cbx,cby)+1e-6;
      return Math.acos(Math.max(-1,Math.min(1,dot/mag)))*180/Math.PI;
    }

    function drawLandmarks(lms){
      if (!lms) return;
      ctx.fillStyle='#FFC0CB';
      for (const p of lms){
        const q=toPix(p);
        ctx.beginPath(); ctx.arc(q.x, q.y, 3, 0, Math.PI*2); ctx.fill();
      }
      if (lms[15]) { const q=toPix(lms[15]); ctx.beginPath(); ctx.arc(q.x,q.y,6,0,Math.PI*2); ctx.fill(); }
      if (lms[16]) { const q=toPix(lms[16]); ctx.beginPath(); ctx.arc(q.x,q.y,6,0,Math.PI*2); ctx.fill(); }
    }

    // ---------- FORM CHECK (existing)
    function isArmsUp(lm){
      const Ls=lm[11], Le=lm[13], Lw=lm[15];
      const Rs=lm[12], Re=lm[14], Rw=lm[16];
      if (![Ls,Le,Lw,Rs,Re,Rw].every(visOK)) return false;

      const wristsAbove=(Lw.y < Ls.y - 0.02) && (Rw.y < Rs.y - 0.02);
      const leftElbow=angle(Ls,Le,Lw), rightElbow=angle(Rs,Re,Rw);
      const elbowsOpen=(leftElbow>120 && rightElbow>120);
      return wristsAbove && elbowsOpen;
    }

    // Pose evaluation functions
    function shoulderFlexion(lm) {
      if (!lm[11] || !lm[15]) return false;
      // Left wrist above left shoulder by 5% of image height
      return lm[15].y < lm[11].y - 0.05;
    }

    function sitToStand(lm) {
      // Example: hips (23) rise above a certain threshold
      if (!lm[23]) return false;
      // Check if left hip is above 70% of image height
      return lm[23].y < 0.70;
    }

    function evaluatePose(criteria, lm) {
      switch (criteria) {
        case "shoulderFlexion": return shoulderFlexion(lm);
        case "sitToStand": return sitToStand(lm);
        default: return false;
      }
    }

    function bopMascot(){ 
      mascot.classList.remove('celebrate'); 
      void mascot.offsetWidth;
      mascot.classList.add('celebrate'); 
    }

    // ---------- UNIFIED RAINBOW ARC STARS (shoulder abduction only)
    const SIDE = { L: 'left', R: 'right' };
    let rainbowStars = [];
    let currentStepL = 0, currentStepR = 0;
    let ascending = true;
    let starRadius = 40;

    function setupRainbowStars() {
      const N = 4; // Number of stars per side
      const arcRadius = canvas.width * 0.27;
      const baseY = canvas.height * 0.74; // Hip/waist level
      const topY = canvas.height * 0.19;  // Overhead
      const midY = (baseY + topY) / 2;
      const cxL = canvas.width * 0.29;
      const cxR = canvas.width * 0.715;
      starRadius = Math.max(22, Math.min(44, canvas.width * 0.023));
      rainbowStars = [];
      // Use angles so all stars are evenly spaced along an arc
      // Arc spans from 65deg to 115deg for each arm (~50deg arc)
      const degToRad = Math.PI / 180;
      const thetaStart = 115 * degToRad;
      const thetaEnd = 65 * degToRad;
      for (let i = 0; i < N; i++) {
        const theta = thetaStart + (thetaEnd - thetaStart) * (i / (N - 1));
        // Left group (blue, left wrist)
        rainbowStars.push({
          x: cxL + arcRadius * Math.cos(theta),
          y: midY - arcRadius * Math.sin(theta),
          hit: false,
          number: i + 1,
          side: SIDE.L,
          color: '#4da3ff'
        });
        // Right group (pink, right wrist, mirrored)
        rainbowStars.push({
          x: cxR - arcRadius * Math.cos(theta),
          y: midY - arcRadius * Math.sin(theta),
          hit: false,
          number: i + 1,
          side: SIDE.R,
          color: '#ff6fb0'
        });
      }
      currentStepL = 0;
      currentStepR = 0;
      ascending = true;
    }

    function drawRainbowStars() {
      for (let s = 0; s < rainbowStars.length; s++) {
        const star = rainbowStars[s];
        ctx.save();
        let isCurrent =
          (star.side === SIDE.L && s % 2 === 0 && s / 2 === currentStepL && !star.hit) ||
          (star.side === SIDE.R && s % 2 === 1 && (s - 1) / 2 === currentStepR && !star.hit);

        ctx.globalAlpha = star.hit ? 0.18 : 1;
        ctx.shadowColor = isCurrent ? star.color : 'rgba(0,0,0,0)';
        ctx.shadowBlur = isCurrent ? 30 : 0;
        ctx.fillStyle = star.color;
        starPath(star.x, star.y, 5, starRadius, starRadius * 0.44);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2.1;
        ctx.strokeStyle = '#fff';
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${starRadius}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(star.number, star.x, star.y);
        ctx.restore();
      }
    }

    function updateRainbowBilateralHits(lm) {
      // Left
      let starL = rainbowStars[0 + currentStepL * 2];
      if (
        starL &&
        !starL.hit &&
        lm[15] && lm[15].visibility > 0.25 &&
        dist(toPix(lm[15]), starL) <= starRadius + 30
      ) {
        starL.hit = true;
        playDing(); bopMascot();
        if (ascending) currentStepL++;
        else currentStepL--;
      }
      // Right
      let starR = rainbowStars[1 + currentStepR * 2];
      if (
        starR &&
        !starR.hit &&
        lm[16] && lm[16].visibility > 0.25 &&
        dist(toPix(lm[16]), starR) <= starRadius + 30
      ) {
        starR.hit = true;
        playDing(); bopMascot();
        if (ascending) currentStepR++;
        else currentStepR--;
      }
      // State changes
      const finishedUp = ascending && currentStepL >= 4 && currentStepR >= 4;
      const finishedDown = !ascending && currentStepL < 1 && currentStepR < 1;
      if (finishedUp) {
        ascending = false;
        currentStepL = 3; currentStepR = 3;
        status("Great! Now lower both arms and burst the stars coming down!");
        for (let s of rainbowStars) s.hit = false;
      }
      if (finishedDown) {
        status("Excellent! Rainbow completed. Raise again to start over!");
        setTimeout(() => {
          for (let s of rainbowStars) s.hit = false;
          ascending = true; currentStepL = 0; currentStepR = 0;
          status("Raise both arms to burst stars from 1 to 4!");
        }, 1600);
      }
    }

    // ---------- GAME LOGIC
    function updateGame(correct){
      const now=Date.now();
      if (correct) framesCorrect++; else framesCorrect=0;
      if (framesCorrect>=NEED_CONSEC_FRAMES && (now-lastRepAt)>REP_COOLDOWN_MS){
        score+=10; streak+=1; energy=Math.min(100, energy+4);
        lastRepAt=now; framesCorrect=0; bopMascot();
        repCount++; // Increment reps done for the exercise
        updateExerciseInfo();

        // Progress to next exercise if completed
        if (repCount >= currentExercise.repetitions_target) {
          currentExerciseIndex++;
          if (currentExerciseIndex < exercises.length) {
            currentExercise = exercises[currentExerciseIndex];
            repCount = 0;
            updateExerciseInfo();
            status(`Level Up! Now: ${currentExercise.name}`);
            if (currentExercise.criteria === 'shoulderAbduction') {
              setupRainbowStars();
            }
          } else {
            status('All exercises complete! ðŸŽ‰');
          }
        }
      } else if (!correct) {
        streak=0; energy=Math.max(0, energy-0.4);
      }
      scoreEl.textContent=score; streakEl.textContent=streak; energyEl.value=energy;
    }

    // ---------- FALLING NOTES (single-star mode)
    const SINGLE_STAR_MODE = true;
    const LANES = [0.18, 0.38, 0.50, 0.62, 0.82];  // % width positions
    const HAND_BONUS = 28;                         // forgiving hitbox
    const ELBOW_STRAIGHT_DEG = 150;
    const NOTE_SPEED_PX_S = 100;                   // falling speed (px/sec)
    const MISS_Y_FRAC = 0.60;                      // miss if star falls past this
    let   TARGET_SPAWN_Y = -60;                    // set in setCanvasSize
    let   MISS_Y = 300;                            // set in setCanvasSize
    const HIT_GRACE_FRAMES = 2;                    // frames inside to register a hit
    const POST_HIT_DESPAWN_MS = 700;               // explosion duration
    const NEXT_DELAY_MS = 300;                     // delay before next star appears

    const SMOOTH_ALPHA = 0.35;
    let stars = []; // at most 1 item
    let lastHitAt = 0;
    let feedbackMsg = '';
    let combo = 0;
    let nextAllowedSpawnAt = 0; // enforce delay after resolve

    const smooth = {
      leftWrist:null, rightWrist:null,
      leftElbow:null, rightElbow:null,
      leftShoulder:null, rightShoulder:null
    };

    function ema(prev, curr) {
      if (!prev) return {x:curr.x, y:curr.y, c:curr.c ?? 1};
      return {
        x: prev.x + SMOOTH_ALPHA*(curr.x - prev.x),
        y: prev.y + SMOOTH_ALPHA*(curr.y - prev.y),
        c: Math.max(prev.c ?? 0, curr.c ?? 0)
      };
    }
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    function elbowAngle(shoulder, elbow, wrist) {
      const ux = shoulder.x - elbow.x, uy = shoulder.y - elbow.y;
      const vx = wrist.x - elbow.x,   vy = wrist.y - elbow.y;
      const dot = ux*vx + uy*vy;
      const mu = Math.hypot(ux,uy) * Math.hypot(vx,vy);
      if (mu === 0) return 180;
      let cos = dot / mu;
      cos = Math.max(-1, Math.min(1, cos));
      return (Math.acos(cos)*180/Math.PI);
    }

    function starPath(cx, cy, spikes, outerR, innerR, rotation=-Math.PI/2){
      const step = Math.PI / spikes;
      ctx.beginPath();
      for (let i=0;i<spikes*2;i++){
        const r = (i%2===0) ? outerR : innerR;
        const a = i*step + rotation;
        const x = cx + Math.cos(a)*r;
        const y = cy + Math.sin(a)*r;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }

    function spawnExplosionParticles(x,y,color){
      const parts=[];
      for (let i=0;i<16;i++){
        const a = (i/16)*Math.PI*2 + Math.random()*0.3;
        const sp = 2.2 + Math.random()*2.2;
        parts.push({
          x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp,
          life: 520 + Math.random()*200, born: performance.now(), color
        });
      }
      return parts;
    }

    function spawnSingleStar(now){
      if (!SINGLE_STAR_MODE) return;
      if (stars.length > 0 || now < nextAllowedSpawnAt) return;

      // Find which Mediapipe landmark to use
      const lmIndex = currentExercise.criteria === 'shoulderFlexion' ? 15 :
                      currentExercise.criteria === 'sitToStand' ? 23 :
                      null;

      let x = canvas.width / 2; // fallback center
      let y = TARGET_SPAWN_Y;   // always start just offscreen

      if (lmIndex !== null && latestLm && latestLm[lmIndex]) {
        const targetPix = toPix(latestLm[lmIndex]);
        x = targetPix.x;
        // For shoulder flexion, spawn at ~36% canvas height; for sit-to-stand, ~70%
        y = currentExercise.criteria === 'shoulderFlexion'
            ? canvas.height * 0.36
            : currentExercise.criteria === 'sitToStand'
              ? canvas.height * 0.70
              : TARGET_SPAWN_Y;
      }

      const side = lmIndex === 15 ? SIDE.L : SIDE.R;
      const baseR = Math.max(30, Math.min(60, canvas.width * 0.035));

      stars = [{
        x, y, r: baseR,
        vy: NOTE_SPEED_PX_S, side,
        spawnedAt: now,
        hit:false, hitAt:0, holdFrames:0, inside:false,
        particles:[]
      }];
    }

    // main update for targets (with dt in seconds)
    function updateCoachAndTargets(lm, dt, now){
      // smooth keypoints
      if (lm) {
        const LW = toPix(lm[15]), RW = toPix(lm[16]);
        const LE = toPix(lm[13]), RE = toPix(lm[14]);
        const LS = toPix(lm[11]), RS = toPix(lm[12]);

        if (visOK(lm[15])) smooth.leftWrist  = ema(smooth.leftWrist, LW);
        if (visOK(lm[16])) smooth.rightWrist = ema(smooth.rightWrist, RW);
        if (visOK(lm[13])) smooth.leftElbow  = ema(smooth.leftElbow, LE);
        if (visOK(lm[14])) smooth.rightElbow = ema(smooth.rightElbow, RE);
        if (visOK(lm[11])) smooth.leftShoulder = ema(smooth.leftShoulder, LS);
        if (visOK(lm[12])) smooth.rightShoulder= ema(smooth.rightShoulder, RS);
      }

      // ensure exactly one star active
      spawnSingleStar(now);

      let bestMsg = '';

      for (const s of stars){
        // fall
        if (!s.hit){
          s.y += s.vy * dt; // constant speed fall

          const wrist   = s.side===SIDE.L ? smooth.leftWrist  : smooth.rightWrist;
          const shoulder= s.side===SIDE.L ? smooth.leftShoulder: smooth.rightShoulder;
          const elbow   = s.side===SIDE.L ? smooth.leftElbow  : smooth.rightElbow;

          s.inside = false;

          if (wrist && shoulder && elbow){
            if (dist(wrist, s) <= s.r + HAND_BONUS){
              s.inside = true;
              s.holdFrames++;
              if (s.holdFrames >= HIT_GRACE_FRAMES && now - lastHitAt > 200) {
                // HIT!
                s.hit = true;
                s.hitAt = now;
                lastHitAt = now;
                combo++; score += 15; starCount += 1; streak += 1;
                energy = Math.min(100, energy+6);
                s.particles = spawnExplosionParticles(s.x, s.y, s.side===SIDE.L ? '#ffd54a' : '#ff9bd3');
                playDing(); bopMascot();
              }
            } else {
              s.holdFrames = 0;
              if (!bestMsg) bestMsg = correctionFor(s.side, wrist, shoulder, elbow, s);
            }
          }

          // Miss if it falls too low
          if (!s.hit && s.y > MISS_Y){
            combo = 0;
            energy = Math.max(0, energy - 3);
            // remove immediately and schedule next
            stars = [];
            nextAllowedSpawnAt = now + NEXT_DELAY_MS;
          }
        }

        // update particles & cleanup hit star
        if (s.hit){
          // update particles
          if (s.particles && s.particles.length){
            for (const p of s.particles){
              const age = now - p.born;
              p.x += p.vx; p.y += p.vy;
              p.vx *= 0.98; p.vy = p.vy*0.98 + 0.06; // gravity
              p.dead = age > p.life;
            }
            s.particles = s.particles.filter(p=>!p.dead);
          }
          // despawn after explosion window
          if (now - s.hitAt > POST_HIT_DESPAWN_MS){
            stars = [];
            nextAllowedSpawnAt = now + NEXT_DELAY_MS; // only then the next appears
          }
        }
      }

      feedbackMsg = bestMsg;
      // reflect counters
      scoreEl.textContent=score; streakEl.textContent=streak; energyEl.value=energy; starsEl.textContent = starCount;
    }

    function correctionFor(side, wrist, shoulder, elbow, target) {
      if (!wrist || !shoulder || !elbow) return '';
      const msgs = [];
      const verticalGap = wrist.y - target.y;
      if (verticalGap > -12) msgs.push(`Raise your ${side} hand higher`);
      else if (verticalGap < -80) msgs.push(`Lower ${side} hand a bit`);
      const horizontalGap = wrist.x - target.x;
      if (Math.abs(horizontalGap) > 40)
        msgs.push(horizontalGap > 0 ? `Move ${side} hand left` : `Move ${side} hand right`);
      const ang = elbowAngle(shoulder, elbow, wrist);
      if (ang < ELBOW_STRAIGHT_DEG) msgs.push(`Straighten your ${side} arm`);
      return msgs[0] ?? '';
    }

    function drawStarsAndUI(now){
      // draw stars (falling + hit animation)
      stars.forEach(s => {
        ctx.save();
        const isLeft = s.side===SIDE.L;

        const idleFill = isLeft ? '#4da3ff' : '#ff6fb0';
        const idleGlow = isLeft ? 'rgba(80,160,255,0.25)' : 'rgba(255,120,180,0.25)';
        const insideFill = '#ffd54a';
        const stroke = '#ffffffcc';

        let r = s.r, alpha = 1;

        if (!s.hit){
          const t = now - s.spawnedAt;
          const pulse = 1 + 0.12*Math.sin(t/220);
          r = s.r * pulse;
        } else {
          const dt = (now - s.hitAt);
          const k = Math.min(1, dt/350);
          r = s.r * (1 + 0.9*k);        // pop
          alpha = 1 - Math.min(1, dt/650);
        }

        // glow
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r+12, 0, Math.PI*2);
        ctx.fillStyle = idleGlow; ctx.fill();

        // star glyph
        ctx.shadowColor = s.inside ? insideFill : idleFill; 
        ctx.shadowBlur = 18;
        starPath(s.x, s.y, 5, r, r*0.48);
        ctx.fillStyle = s.inside ? insideFill : idleFill; 
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 3; ctx.strokeStyle = stroke; ctx.stroke();

        // L/R label
        ctx.font = 'bold 14px ui-sans-serif';
        ctx.fillStyle = '#0b0f1a';
        ctx.textAlign='center';
        ctx.fillText(isLeft?'L':'R', s.x, s.y+5);

        // particles
        if (s.particles && s.particles.length){
          for (const p of s.particles){
            const age = now - p.born;
            const life = Math.max(0, 1 - age/(p.life));
            ctx.globalAlpha = life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3 + 2*life, 0, Math.PI*2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
        ctx.restore();
      });

      // top bar: combo + feedback
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(10, 10, canvas.width - 20, 44);

      ctx.fillStyle = '#fff';
      ctx.font = '16px ui-monospace,monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`Combo: ${combo}`, 24, 38);

      ctx.textAlign = 'right';
      ctx.fillText(feedbackMsg || (stars.length? 'Catch the star!' : 'Get readyâ€¦'), canvas.width-24, 38);
      ctx.restore();
    }

    // ---------- RENDER LOOP (with dt)
    let _prevNow = performance.now();
    function renderLoop(){
      const now = performance.now();
      const dt = (now - _prevNow)/1000; _prevNow = now;

      drawCameraFrame();
      if (latestLm) {
        drawLandmarks(latestLm);
        if (currentExercise.criteria === 'shoulderAbduction') {
          drawRainbowStars();
          updateRainbowBilateralHits(latestLm);
        } else {
          updateGame(evaluatePose(currentExercise.criteria, latestLm));
          updateCoachAndTargets(latestLm, dt, now);
          drawStarsAndUI(now);
        }
      } else {
        if (currentExercise.criteria !== 'shoulderAbduction') {
          drawStarsAndUI(now);
        }
      }
      requestAnimationFrame(renderLoop);
    }

    // ---------- START
    async function start(){
      if (running) return; running=true;
      try{
        initAudio(); // user gesture â†’ unlock audio
        status('requesting cameraâ€¦');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video:{ facingMode:'user', width:1280, height:720 }, 
          audio:false 
        });
        video.srcObject=stream;
        await new Promise(res=>video.onloadedmetadata=res);
        video.play();
        setCanvasSize();
        window.addEventListener('resize', setCanvasSize);
        renderLoop();
        status('camera ready');

        const PoseCtor = window.Pose || (window.pose && window.pose.Pose);
        if (!PoseCtor){ status('ERROR: Pose constructor not found'); return; }

        const pose = new PoseCtor({
          locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`
        });
        pose.setOptions({
          modelComplexity: 1,
          smoothLandmarks: true,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        pose.onResults(({ poseLandmarks })=>{
          latestLm = poseLandmarks || null;
        });

        if (typeof Camera === 'function'){
          const cam = new Camera(video, {
            onFrame: async () => { await pose.send({ image: video }); },
            width: canvas.width, height: canvas.height
          });
          cam.start();
          status('runningâ€¦ single falling star (L/R) â€” hit to spawn the next!');
        } else {
          status('no Camera helper; using fallback loop');
          (async function loop(){
            await pose.send({ image: video });
            requestAnimationFrame(loop);
          })();
        }
      }catch(e){
        status('ERROR: ' + (e && e.message ? e.message : e));
        console.error(e);
      }
    }
    startBtn.addEventListener('click', start);

    // Update exercise info display
    function updateExerciseInfo() {
      exerciseInfoEl.textContent =
        `${currentExercise.name}: ${currentExercise.description} (${repCount}/${currentExercise.repetitions_target})`;
    }

    // Initialize everything at startup
    currentExerciseIndex = 0;
    repCount = 0;
    currentExercise = exercises[currentExerciseIndex];
    updateExerciseInfo();
    status(`Current Exercise: ${currentExercise.name}`);
  </script>
</body>
</html>
